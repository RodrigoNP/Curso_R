consolas<-as.factor('xbox')
#podemos aniadir niveles de una manera mas sencilla
levels(consolas)<-c('xbox','switch','ps5')
consolas
## Vectores o listas ##
#Podemos concatenar objetos usando el comando c(). De preferencia, que sean del mismo tipo. Un vector es una lista de objetos, una coleccion.
vector<-c(1,4,5,6)
vector<-c(vector, 1,4,6,8,9)
## Slices ##
# Podemos ver partes especificas de los vectores utilizando parentesis.
#Dentro de los parentesis ponemos las posiciones deseadas del vector.
vector[3]
#Un operador habital es ':' que se interpreta como de x a y
vector[1:2] #dame los objetos que estan de la posicion uno a la dos
#Podemos hacer particiones de vectores usando operadores logicos
vector[vector<5]
#Para obetener el complemento de ese vector
vector[!vector<5]
#Con este mismo operador podemos hacer series
series<-1:10
series
#Muchas funciones utilizan vectores
mean(vector); sd(vector) ; prod(vector)
#incluso, puedes operar con los mismos vectores. Interpretalo como vectores matematicos: OPERACIONES ENTRADA POR ENTRADA
r<-c(1,4,6,4,2,5,9)
r*2
r+r
r>=4
#Como vimos, podemos utilizar factores para ver cuantas observaciones pertenecen a una categoria
carreras<-c('eco','eco','cpol','ri','ri')
as.factor(carreras)
table(carreras)
# usamos el operador '%in%' para ver si un objeto pertenece a un vector
carreras<-c('eco','eco','cpol','ri','ri')
'mat' %in% carreras
# Para las simulaciones, seguramente usaremos estas funciones
rep(4,4) #repite la primera entrada la cantidad de veces indicada en la segunda entrada
a<-c(1,7,9)
rep(a,3)
numeric(5) #vector de 0 el numero de veces indicada
character(6) # lo mismo, pero para characters
sample(1:10,3) #Del vector indicado,toma una muestra aleatoria del tamanio indicado en la segunda entrada
a<-c(2,4,5,6,1,3,12,45,56)
sample(a,4)
sample(a, 2, replace = F) #podemos indicar con o sin reemplazo
#Podemos tomar particiones usando vectores independientes
coin_toss<-sample(
rep(c('aguila', 'sol')), 10 ,
replace = T)
y<-1:10
y[coin_toss=='aguila']
### Ejercicios de Mauricio Romero ###
#Si f es
f <- c(2,3,4,5)
# que output dara lo siguiente
f^2
f + c(1,2,3,4)
c(f,6)
is.numeric(f)
mean(f >= 4)
f*c(1,2,3)
length(f)
length(rep(1:4,3))
f/2 == 2 | f < 3
as.character(f)
f[1]+f[4]
c(f,f,f,f)
f[f[1]]
f[c(1,3)]
f %in% (1:4*2)
sort(c(1,5,3,7,45,6,23,-45))
## Creacion de DF##
# Aprovechemos lo que aprendimos para crear un DF.
n<-4000
id<-1:n
sex<-sample(c('h','m','o'), n, replace = T)
edad<-floor(runif(n, min=17, max=27)) # Se pueden omitir las palabras max y min y solo poner los numeros
carrera<-sample(c('eco','cpol','ri','derecho','conta','mat'), n, replace = T)
prom<-runif(n, 6, 10)
### Data Frames ###
# Cramos DF con la funcion data.frame()
df<-data.frame(id, sex, edad, carrera, prom)
## Semillas ##
# Por replicabilidad, siempre hay que correr una semilla para que se puedan obtener los mismo datos aleatorios
set.seed(2020)
df<-data.frame(
id=1:n,
sex=sample(c('h','m'), n, replace = T),
edad=floor(runif(n, min=17, max=27)),
carrera=sample(c('eco','cpol','ri','derecho','conta','mat'), n, replace = T),
prom=runif(n, 6, 10)
) #manera alternativa de crear el df directamente, sin crear nuevas variables
## Visualizaciones del df ##
# Muchas maneras de darnos una idea de lo que contiene un df
summary(df)
head(df)
str(df)
## Particiones de DF ##
# Podemos llamar los vectores de las variables con "$"
df$prom
#Podemos operar con este vector como con cualquier otro
mean(df$prom)
df$prom[5]
# podemos tomar rebanadas del df:
# df[filas, columnas]
df[1:2, c(2:3,5)]
## Algunas funciones importantes para DF
# with #
with(df, mean(prom))
######
# Programacion Basica
######
rm(list=ls())
# Creemos de nuevo del df de alumnos del ITAM
set.seed(2020)
n<-4000
df<-data.frame(
id=1:n,
sex=sample(c('h','m','o'), n, replace = T),
edad=floor(runif(n, min=17, max=27)),
carrera=sample(c('eco','cpol','ri','derecho','conta','mat'), n, replace = T),
prom=runif(n, 6, 10)
)
with(df, mean(prom))
## For loops ##
# Si queremos hacer esto varias veces, conviene hacer un foor loop
# Necesitamos un vector vacio para guardar los promedios
means<-NULL
# se acostumbra crear una variable que indique el # de repeticiones para despues modificar facilmente
num.reps<-5000
for (i in 1:num.reps) {
df<-data.frame(
id=1:n,
sex=sample(c('h','m','o'), n, replace = T),
edad=floor(runif(n, min=17, max=27)),
carrera=sample(c('eco','cpol','ri','derecho','conta','mat'), n, replace = T),
prom=runif(n, 6, 10)) #Creamos el df
means[i]<-with(df, mean(prom)) #Guardamos en el vector
}
## Para hacer la gráfica
(plot(density(means),
ylab='',
main = ''))
## Loops sobre variables ##
# usemos una base de datos precargada
data(mtcars)
for (i in c('mpg','hp','qsec','cyl')) {
print(mean(mtcars[[i]]))
}
# mpg, hp, qsec y cyl son variables del df mtcars. Para hacer un loop sobre variables ponemos df[[i]]
#para imprimir mensaje usamos la funcion past0()
for (i in c('mpg','hp','qsec','cyl')) {
print(
paste0(c('El promedio de',i, 'es', mean(mtcars[[i]])))
)
}
# De igual manera, podemos usar str_c() del paquete stringr
library(stringr)
# Solo incluyamos algunos espacios extras
for (i in c('mpg','hp','qsec','cyl')) {
print(
str_c('El promedio de ',i, ' es ', mean(mtcars[[i]]))
)
}
## if ##
# Sirve cuando queremos que R haga algo solo en ciertos casos
if(2>0){
print('Hola')
}
# En caso de que no se cumpla la condicion, no hace nada
## else ##
# Si queremos que haga algo en caso de que la condicion sea falsa
a<-rnorm(1, mean=0, sd=1)
if(a>0){
print('Hola')
} else {
print('Adiós ')
}
## Nested loops ##
# Podemos mezclar if y for
# Necesitamos next y break
# Next pasa al proximo elemento del iterador
# break rompe el ciclo
for (i in 57:65) {
if(!i %%2){
print(i)
next
}
}
for (i in 57:65) {
if(!i %%2){
print(i)
break
}
}
## Funciones ##
# Podemos crear nuestras propias funciones
# func_name <-**function**(input){
#   statement
# return (output)
# }
# Por ejemplo, pensemos en una función que, si le pongo el df de alumnos del ITAM, calcule el promedio de los promedios por carrera.
# Recordemos la base de datos
n<-4000
df<-data.frame(
id=1:n,
sex=sample(c('h','m','o'), n, replace = T),
edad=floor(runif(n, min=17, max=27)),
carrera=sample(c('eco','cpol','ri','derecho','conta','mat'), n, replace = T),
prom=runif(n, 6, 10)
)
# Pensemos en la funcion
career.mean<-function(data_frame){
career_mean<-NULL
for (i in df$carrera ) {
career_mean[i]<-with(subset(df, carrera==i), mean(prom))
}
return(career_mean)
}
career.mean(df)
## Algunas aclaraciones sobre funciones ##
potencia<- function(x, y=2) {
result<-x^y
return(result)
}
potencia(2)
potencia(2,4)
########
## Paquete Data Pliers
#######
rm(list = ls())
### Instalacion de paquetes ###
# Cargamos paquetes (recuerda instalarlos antes)##
# instalamos con: install.packages('paquete')
library(tidyverse)
### Importacion de datos ###
## Datos ya en R
# Si queremos ver la lista de datos ya presentes en R
# data()
# Guardamos las bases de datos
cars<- mtcars
sueño<- sleep
## Directorios
# Consultar el directorio
getwd()
# Cambiar el directorio
setwd('C:/Users/rodri/OneDrive - INSTITUTO TECNOLOGICO AUTONOMO DE MEXICO/Curso_R/02_Dplyr/Data')
# Guardamos la base como un objeto
presidencial<- readxl::read_excel('presidencia.xlsx', skip = 5)
# Analogamente
presidencial<- readxl::read_excel('C:/Users/rodri/OneDrive - INSTITUTO TECNOLOGICO AUTONOMO DE MEXICO/Curso_R/02_Dplyr/Data/presidencia.xlsx',
skip = 5)
### Verbos ###
## rename()
presidencial<-presidencial %>%
rename(votos=TOTAL_VOTOS_CALCULADOS,
lista_nominal=LISTA_NOMINAL_CASILLA)
## mutate()
# Se utiliza para añadir variables
presidencial<- presidencial %>%
mutate(participacion=votos/
lista_nominal)
# Si queremos usar el formato funcion
presidencial<-mutate(presidencial,
participacion=votos/
lista_nominal)
# ifelse()
# Creemos una dummy que indique si una casilla es rural
presidencial<-presidencial %>%
mutate(
rural=ifelse(CASILLA=='Rural',1,0)
)
## filter ()
# Quedemonos con las observaciones en las que hubo votos por algun independiente
independientes<-presidencial %>%
filter(CAND_IND_01>0 | CAND_IND_02>0)
# select()
morena<- presidencial %>%
select(CLAVE_CASILLA, NOMBRE_ESTADO,
contains('MORENA'))
### Agrupar ###
# Agrupar por estado
presidencial<- presidencial %>%
group_by(NOMBRE_ESTADO) %>%
mutate(
voto_morena= mean(MORENA, na.rm=T)
)
# sumarise()
prom_estados<- presidencial %>%
group_by(NOMBRE_ESTADO) %>%
summarise(
across(PAN:CAND_IND_02, sum)
)
## rowwise()
# Para operar con dplyr a lo largo de las filas
presidencial<- presidencial %>%
rowwise() %>%
mutate(
total_morena= sum(c_across(contains('MORENA')))- voto_morena
)
presidencial<- presidencial %>%
mutate(
participativo=case_when(
participacion<0.30 ~ 'poco',
participacion>0.30 & participacion<=0.60 ~ 'promedio',
participacion>0.60 ~ 'muy'
)
)
## pivot_longer()
presidencial_long<- presidencial %>%
pivot_longer(PAN:CAND_IND_02,
names_to = 'partido',
values_to = 'votos_partido') %>%
select(CLAVE_CASILLA, partido, votos_partido, everything())
# Agrupar con con un formato long()
# Para obtener los votos por partido a nivel nacional
voto.por.partido<- presidencial_long %>%
group_by(partido) %>%
summarise(
nacional_partido=sum(votos_partido, na.rm = T)
)
# arrange()
# usemos arrange para identificar al ganador para cada casilla
presidencial_long <- presidencial_long %>%
group_by(CLAVE_CASILLA) %>%
arrange(desc(votos_partido), .by_group = T) %>%
mutate(ranking=row_number(),
ganador=first(partido))
## pivot_wider()
presidencial_wide<- presidencial_long %>%
pivot_wider(names_from = partido,
values_from = votos_partido)
######
## ggplot
######
rm(list = ls())
## Cargamos paquetes
library(tidyverse)
## Trabajemos con mtcars
cars<- mpg
## Graficando la relación entre tamaño y eficiencia
ggplot(data=cars)+
geom_point(mapping = aes(x= displ, y= hwy))
# Podemos guardar las gráficas como objetos
figura.1<- ggplot(data=cars)+
geom_point(mapping = aes(x= displ, y= hwy))
# Si queremos que lo muestre, lo podemos poner entre paréntesis
(figura.1<- ggplot(data=cars)+
geom_point(mapping = aes(x= displ, y= hwy)))
# Una vez creada la grafica, podemos añadir elementos
(ggplot(data=cars)+
geom_point(mapping = aes(x= displ, y= hwy))+
xlab('Volumen Motor (l)')+
ylab('Millas por galón')+
ggtitle('Eficiencia')+
theme_minimal()+
coord_flip())
# Si ya tenemos la gráfica como objeto guardado, basta con poner el nombre del objeto seguido de los elementos
(figura.1+
xlab('Volumen Motor (l)')+
ylab('Millas por galón')+
ggtitle('Eficiencia')+
theme_minimal()+
coord_flip())
### Parte de dplyr ###
# Podemos concatenar ggplot usando la pipa %>%. En este caso, omitimos el argumento de df y ponemos solo la aestetica dentro de ggplot()
# Por ejemplo repliquemos la gráfica, pero solo para los compactos
(figura.2<- cars %>%
filter(class=='compact') %>%
ggplot(aes(x=displ, y =hwy))+
geom_point())
### Aestetica ###
# Podemos vincular a una caracteristica estetica del grafico a una variable de factor, que, a la postre, va a asignar un nivel a cada categoria
(aes<- ggplot(data=cars)+
geom_point(mapping = aes(x= displ, y= hwy,
color=class)))
# Podemos haer lo mismo con formas
(aes.2<- ggplot(data=cars)+
geom_point(mapping = aes(x= displ, y= hwy,
color=class, shape=class)))
## Dentro vs fuera de aes() ##
# Para especificar que queremos un color en particular ponemos el argumento dentro de la geometria pero fuera de aes(). No vinculamos una cuestión estética con una variable, sino que solo forzamos que la figura sea un color especifico
(fuera_aes<- ggplot(data=cars)+
geom_point(mapping = aes(x= displ, y= hwy) ,
color='red'))
## aplha ##
(aes.3<- ggplot(data=cars)+
geom_point(mapping = aes(x= displ, y= hwy,
color=class, alpha=class)))
## Escalas de colores
# Descarguemos la paleta Viridis
library(viridis)
(scale_color <- ggplot(data=cars)+
geom_point(mapping = aes(x= displ, y= hwy,
color=class))+
scale_color_viridis(discrete = T,
option = 'magma'))
### Facets ###
# Podemos dividir los facets, haciendo una grafica para cada categoria
# Tenemos que especificar la formula con la variable para la que queremos descomponer la grafica antcipiada por ~
(facets <- ggplot(cars)+
geom_point(mapping =
aes(x= displ, y= hwy))+
facet_wrap(~ class, nrow = 2))
# Podemos descomponer en varias variables especificando en la forumla
(facets <- ggplot(cars)+
geom_point(mapping =
aes(x= displ, y= hwy))+
facet_wrap(cyl ~ class))
#### Otra sintaxis ####
# Podemos omitir cosas como mapeo x y y
# Podemos incluir la aestetica en ggplot() pero el resto de los argumentos de la geometria siguen especificandose dentro de la geometria
(figura.1.2 <- ggplot(cars,
aes(displ, hwy, color= class))+
geom_point())
#### Geometrías ###
## geom_smooth()
# aniade linea de regresion e intervalos de confianza
(smooth <- ggplot(cars)+
geom_smooth(mapping = aes(
x=displ, y= hwy,
linetype= drv, color=drv
)))
## Múltiples geometrías ##
# Con la sintaxis alternativa es muy snecillo aniadir multiples geometrias
# Solo especificamos las cosas comunes en ggplot()
(mult_geom <- ggplot(cars,
aes(displ, hwy,
color= drv, linetype=drv))+
geom_point()+
geom_smooth())
# Podemos jugar con las opciones
(mult_geom.2 <- ggplot(mpg,
aes(displ, hwy))+
geom_point(aes(color=class))+
geom_smooth(data= filter(mpg,
class=='subcompact'), color='red'))
## Grafico de barras ##
# su stat default es count
(bar <- ggplot(cars)+
geom_bar( aes(class)))
# Creemos un df para hacer el grafico de barras
cars_count <- cars %>%
group_by(class) %>%
summarise(n=n())
# podemos hacer lo mismo, pero especificando las variables ya hechas
# stat= 'idenity'
(cars_count <- cars %>%
group_by(class) %>%
summarise(n=n()) %>%
ggplot(aes(class, n))+
geom_bar(stat = 'identity'))
## Gráfico de barras de proporciones
(bar_prop <- ggplot(cars)+
geom_bar(aes(class, y=..prop..,
group=1)))
## fill vs color ##
(bar_color <- ggplot(cars)+
geom_bar(aes(class,
color=drv)))
(bar_fill <- ggplot(cars)+
geom_bar(aes(class,
fill=drv)))
## position = ' ' ##
(bar_position_fill <- ggplot(cars)+
geom_bar(aes(class,
fill=drv), position='fill'))
(bar_position_dodge <- ggplot(cars)+
geom_bar(aes(class,
fill=drv), position='dodge'))
#### Histograma y densidad ####
# para generar el df
set.seed(2022)
n <- 100
mean_h <- 30000
mean_m <- 24000
sd_h <- 3000
sd_m <- 5000
salarios <- tibble(
id=seq(n),
sexo= factor(rep(c('m','h'), each= n/2)),
salario= round(c(rnorm(n/2, mean_m, sd_m),
rnorm(n/2, mean_h, sd_h)))
)
# Densidad con línea vertical
(density <- ggplot(salarios,
aes(salario))+
geom_density()+
geom_vline(aes(xintercept=mean(salario))))
# si queremos distinguir por sexo
(density_group <- ggplot(salarios,
aes(salario, color= sexo))+
geom_density()+
geom_vline(aes(xintercept=mean(salario)),
color='red'))
### Histograma ###
# Evidentemente, el histograma es muy similar a la densidad
(histogram_b <- ggplot(salarios,
aes(salario))+
geom_histogram(bins=10))
# Podemos modificar el numero de marcas de clase con bins, que ajusta automaticamente las marcas de clase al numero deseado
# Podemos especificar la longitud de la clase con bandwith.
(histogram_bwidth <- ggplot(salarios,
aes(salario))+
geom_histogram(binwidth = 5000))
# Tambien podemos hacer la figura distinguiendo por sexo
(histogram_sexo <-
ggplot(salarios,
aes(salario, color= sexo))+
geom_histogram(binwidth = 2500,
position= 'dodge',
fill='white'))
